---
- hosts: k8s
  become: true
  vars:
    local_user: fredrick
  tasks:
    - name: kubeadm - create kubeconfig for terraform
      command: kubeadm kubeconfig user --config /etc/kubernetes/kube-init-config.yaml --client-name {{ ansible_hostname }} --validity-period 8760h
      register: kubeconfig_terraform

    - name: kubectl - grant terraform user cluster-admin role
      shell: KUBECONFIG=/etc/kubernetes/admin.conf kubectl create clusterrolebinding {{ ansible_hostname }} --clusterrole=cluster-admin --user={{ ansible_hostname }}

    - name: create dir
      file:
        path: /home/{{ local_user }}/.kube
        state: directory
        owner: "{{ local_user }}"
        group: "{{ local_user }}"
        mode: 0600
    # Not really necessary, but I like to keep the kubeconfig as a backup on the node
    - name: kubectl - store kubeconfig on remote target
      copy:
        dest: /home/{{ local_user }}/.kube/config
        content: "{{ kubeconfig_terraform.stdout }}"
        owner: "{{ local_user }}"
        group: "{{ local_user }}"
        mode: 0600

#################
## Workstation ##
#################

    - name: create dir
      file:
        path: /tmp/kubeconfigs
        state: directory
        mode: 0775
      delegate_to: localhost
      become_user: "{{ local_user }}"
    - name: kubectl - store kubeconfig on local machine
      copy:
        dest: /tmp/kubeconfigs/{{ inventory_hostname }}
        content: "{{ kubeconfig_terraform.stdout }}"
      delegate_to: localhost
      become_user: "{{ local_user }}"

    - name: kubeconfig - remove old config
      file:
        path: ~/.kube/config_homelab
        state: absent

    - name: kubeconfig - merge kubeconfig files
      shell: KUBECONFIG=$(find /tmp/kubeconfigs -type f | tr '\n' ':') kubectl config view --flatten > ~/.kube/config_homelab
      delegate_to: localhost
      become_user: "{{ local_user }}"
      run_once: true

    - name: set fact with ansible_hostname, without k8s- prefix
      set_fact:
        k8s_environment: "{{ ansible_hostname | regex_replace('^k8s-') }}"

    - name: kubeconfig - rename contexts
      shell: KUBECONFIG=~/.kube/config_homelab kubectl config rename-context {{ ansible_hostname }}@{{ ansible_hostname }} {{ k8s_environment }}
      delegate_to: localhost
      become_user: "{{ local_user }}"
      throttle: 1 # run in sequence to avoid .lock file issues

#########################
## GCP Secret Mananger ##
#########################

    - name: gcpsm - check if secret exist
      shell: gcloud secrets describe {{ ansible_hostname }}
      delegate_to: localhost
      become_user: "{{ local_user }}"
      ignore_errors: true
      no_log: true
      register: gcpsm_check_output
      failed_when: gcpsm_check_output.rc != 0

    - name: gcpsm - create secret if it doesn't exist
      shell: gcloud secrets create {{ ansible_hostname }} --replication-policy=automatic
      delegate_to: localhost
      become_user: "{{ local_user }}"
      when: gcpsm_check_output.rc != 0

    - name: gcpsm - nuke existing kubectl secret(s)
      shell: |
        secret_versions=$(gcloud secrets versions list {{ ansible_hostname }} --filter enabled --format value\(name\))
        for version in $secret_versions
        do
          gcloud secrets versions destroy $version --secret={{ ansible_hostname }} --quiet
        done
      delegate_to: localhost
      become_user: "{{ local_user }}"
      register: gcpsm_nuke_kubectl_output

    - name: gcpsm - debug message nuke result
      debug:
        msg: "{{ gcpsm_nuke_kubectl_output.stderr }}" # blame gcloud, they output to stderr on success

    - name: gcpsm - upload kubectl content to new secret version
      shell: echo {{ kubeconfig_terraform.stdout | quote }} | gcloud secrets versions add --data-file=- {{ ansible_hostname }}
      delegate_to: localhost
      become_user: "{{ local_user }}"
      register: gcpsm_upload_kubectl_output

    - name: gcpsm - debug message upload result
      debug:
        msg: "{{ gcpsm_upload_kubectl_output.stderr }}" # blame gcloud, they output to stderr on success
